{"version":3,"file":"filter-godray.js","sources":["../src/GodrayFilter.js"],"sourcesContent":["import {vertex} from '@tools/fragments';\nimport perlin from './perlin.frag';\nimport fragment from './gorday.frag';\nimport {Filter} from '@pixi/core';\nimport {Point, DEG_TO_RAD} from '@pixi/math';\n\n/**\n * GordayFilter, {@link https://codepen.io/alaingalvan originally} by Alain Galvan\n *\n *\n *\n * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/godray.gif)\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n * @see {@link https://www.npmjs.com/package/@pixi/filter-godray|@pixi/filter-godray}\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n *\n * @example\n *  displayObject.filters = [new GodrayFilter()];\n * @param {object} [options] Filter options\n * @param {number} [options.angle=30] Angle/Light-source of the rays.\n * @param {number} [options.gain=0.5] General intensity of the effect.\n * @param {number} [options.lacunrity=2.5] The density of the fractal noise.\n * @param {boolean} [options.parallel=true] `true` to use `angle`, `false` to use `center`\n * @param {number} [options.time=0] The current time position.\n * @param {PIXI.Point|number[]} [options.center=[0,0]] Focal point for non-parallel rays,\n *        to use this `parallel` must be set to `false`.\n * @param {number} [options.alpha=1.0] the alpha, defaults to 1, affects transparency of rays\n */\nclass GodrayFilter extends Filter {\n    constructor(options) {\n        super(vertex, fragment.replace('${perlin}', perlin));\n\n        this.uniforms.dimensions = new Float32Array(2);\n\n        // Fallback support for ctor: (angle, gain, lacunarity, time)\n        if (typeof options === 'number') {\n            // eslint-disable-next-line no-console\n            console.warn('GodrayFilter now uses options instead of (angle, gain, lacunarity, time)');\n            options = { angle: options };\n            if (arguments[1] !== undefined) {\n                options.gain = arguments[1];\n            }\n            if (arguments[2] !== undefined) {\n                options.lacunarity = arguments[2];\n            }\n            if (arguments[3] !== undefined) {\n                options.time = arguments[3];\n            }\n            if (arguments[4] !== undefined) {\n                options.alpha = arguments[4];\n            }\n        }\n\n        options = Object.assign({\n            angle: 30,\n            gain: 0.5,\n            lacunarity: 2.5,\n            time: 0,\n            parallel: true,\n            center: [0, 0],\n            alpha: 1,\n        }, options);\n\n        this._angleLight = new Point();\n        this.angle = options.angle;\n        this.gain = options.gain;\n        this.lacunarity = options.lacunarity;\n        this.alpha = options.alpha;\n\n        /**\n         * `true` if light rays are parallel (uses angle),\n         * `false` to use the focal `center` point\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.parallel = options.parallel;\n\n        /**\n         * The position of the emitting point for light rays\n         * only used if `parallel` is set to `false`.\n         *\n         * @member {PIXI.Point|number[]}\n         * @default [0, 0]\n         */\n        this.center = options.center;\n\n        /**\n         * The current time.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.time = options.time;\n    }\n\n    /**\n     * Applies the filter.\n     * @private\n     * @param {PIXI.FilterManager} filterManager - The manager.\n     * @param {PIXI.RenderTarget} input - The input target.\n     * @param {PIXI.RenderTarget} output - The output target.\n     */\n    apply(filterManager, input, output, clear) {\n        const {width, height} = input.filterFrame;\n\n        this.uniforms.light = this.parallel ? this._angleLight : this.center;\n\n        this.uniforms.parallel = this.parallel;\n        this.uniforms.dimensions[0] = width;\n        this.uniforms.dimensions[1] = height;\n        this.uniforms.aspect = height / width;\n        this.uniforms.time = this.time;\n        this.uniforms.alpha = this.alpha;\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clear);\n    }\n\n    /**\n     * The angle/light-source of the rays in degrees. For instance, a value of 0 is vertical rays,\n     *     values of 90 or -90 produce horizontal rays.\n     * @member {number}\n     * @default 30\n     */\n    get angle() {\n        return this._angle;\n    }\n    set angle(value) {\n        this._angle = value;\n\n        const radians = value * DEG_TO_RAD;\n\n        this._angleLight.x = Math.cos(radians);\n        this._angleLight.y = Math.sin(radians);\n    }\n\n    /**\n     * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n     * where a value closer to 0 will produce a subtler effect.\n     *\n     * @member {number}\n     * @default 0.5\n     */\n    get gain() {\n        return this.uniforms.gain;\n    }\n    set gain(value) {\n        this.uniforms.gain = value;\n    }\n\n    /**\n     * The density of the fractal noise. A higher amount produces more rays and a smaller amound\n     * produces fewer waves.\n     *\n     * @member {number}\n     * @default 2.5\n     */\n    get lacunarity() {\n        return this.uniforms.lacunarity;\n    }\n    set lacunarity(value) {\n        this.uniforms.lacunarity = value;\n    }\n\n    /**\n     * The alpha (opacity) of the rays.  0 is fully transparent, 1 is fully opaque\n     * @member {number}\n     * @default 1\n     */\n    get alpha() {\n        return this.uniforms.alpha;\n    }\n    set alpha(value) {\n        this.uniforms.alpha = value;\n    }\n}\n\nexport { GodrayFilter };\n"],"names":["GodrayFilter","options","super","vertex","fragment","replace","perlin","this","uniforms","dimensions","Float32Array","console","warn","angle","undefined","arguments","gain","lacunarity","time","alpha","Object","assign","parallel","center","_angleLight","Point","apply","filterManager","input","output","clear","filterFrame","light","width","height","aspect","applyFilter","prototypeAccessors","_angle","value","const","radians","DEG_TO_RAD","x","Math","cos","y","sin","Filter"],"mappings":";;;;;;;8rJA8BMA,cACF,WAAYC,GACRC,YAAMC,EAAQC,EAASC,QAAQ,YAAaC,IAE5CC,KAAKC,SAASC,WAAa,IAAIC,aAAa,GAGrB,iBAAZT,IAEPU,QAAQC,KAAK,4EACbX,EAAU,CAAEY,MAAOZ,QACEa,IAAjBC,UAAU,KACVd,EAAQe,KAAOD,UAAU,SAERD,IAAjBC,UAAU,KACVd,EAAQgB,WAAaF,UAAU,SAEdD,IAAjBC,UAAU,KACVd,EAAQiB,KAAOH,UAAU,SAERD,IAAjBC,UAAU,KACVd,EAAQkB,MAAQJ,UAAU,KAIlCd,EAAUmB,OAAOC,OAAO,CACpBR,MAAO,GACPG,KAAM,GACNC,WAAY,IACZC,KAAM,EACNI,UAAU,EACVC,OAAQ,CAAC,EAAG,GACZJ,MAAO,GACRlB,GAEHM,KAAKiB,YAAc,IAAIC,QACvBlB,KAAKM,MAAQZ,EAAQY,MACrBN,KAAKS,KAAOf,EAAQe,KACpBT,KAAKU,WAAahB,EAAQgB,WAC1BV,KAAKY,MAAQlB,EAAQkB,MASrBZ,KAAKe,SAAWrB,EAAQqB,SASxBf,KAAKgB,OAAStB,EAAQsB,OAQtBhB,KAAKW,KAAOjB,EAAQiB,2NAUxBQ,eAAMC,EAAeC,EAAOC,EAAQC,GAChC,MAAwBF,EAAMG,iCAE9BxB,KAAKC,SAASwB,MAAQzB,KAAKe,SAAWf,KAAKiB,YAAcjB,KAAKgB,OAE9DhB,KAAKC,SAASc,SAAWf,KAAKe,SAC9Bf,KAAKC,SAASC,WAAW,GAAKwB,EAC9B1B,KAAKC,SAASC,WAAW,GAAKyB,EAC9B3B,KAAKC,SAAS2B,OAASD,EAASD,EAChC1B,KAAKC,SAASU,KAAOX,KAAKW,KAC1BX,KAAKC,SAASW,MAAQZ,KAAKY,MAG3BQ,EAAcS,YAAY7B,KAAMqB,EAAOC,EAAQC,IASnDO,EAAIxB,qBACA,OAAON,KAAK+B,QAEhBD,EAAIxB,mBAAM0B,GACNhC,KAAK+B,OAASC,EAEdC,IAAMC,EAAUF,EAAQG,aAExBnC,KAAKiB,YAAYmB,EAAIC,KAAKC,IAAIJ,GAC9BlC,KAAKiB,YAAYsB,EAAIF,KAAKG,IAAIN,IAUlCJ,EAAIrB,oBACA,OAAOT,KAAKC,SAASQ,MAEzBqB,EAAIrB,kBAAKuB,GACLhC,KAAKC,SAASQ,KAAOuB,GAUzBF,EAAIpB,0BACA,OAAOV,KAAKC,SAASS,YAEzBoB,EAAIpB,wBAAWsB,GACXhC,KAAKC,SAASS,WAAasB,GAQ/BF,EAAIlB,qBACA,OAAOZ,KAAKC,SAASW,OAEzBkB,EAAIlB,mBAAMoB,GACNhC,KAAKC,SAASW,MAAQoB,6CAlJHS"}